This README explains how to run a combination of Daisy, Metalibm and Xilinx to reproduce the experiments in the paper:

*Izycheva A., Darulova E., Seidl H. **Synthesizing Efficient Low-Precision Kernels** ATVA'19*

This directory contains the following:

+ Daisy only 
    + atva_experiments.sh - script to run Daisy - performs a set of experiments for different finite-precision allocation strategies. Has been used for extensive evaluation to find the best setting. Takes several hours to finish.
However, one can comment out undesired experiment series. 
    + run_daisy.sh - script to run Daisy from atva_experiments.sh (the atva_experiments.sh script sets all necessary flags and parameters)
+ Xilinx Vivado HLS only
    + atva_xilinx.sh - Script to run Vivado HLS on the files generated by atva_experiments.sh. 
    + run_xilinx.sh - Script to run Vivado HLS with necessary parameters. 
+ Full experiments 
    + synthesis_*.sh  - Scripts to run experiments 
+ Assisting scripts
    + ParseLogs.py  - Python script to present experimental results in a unified table form 
    + vivado_run.tcl - Script to compile the generated cpp files with Xilinx Vivado HLS 

## Installation
*Already described in the README of the home directory. Duplicated here*
### Daisy
To run the scripts for experiments compile Daisy and create the daisy-script by running:

```
$ sbt compile && sbt script
```

### Metalibm and its dependencies
First install the dependencies for Metalibm. On MacOS run:

```
$ brew install automake libtool autoconf libxml2 gmp mpfr mpfi boost
```

Manually install [FPLLL](https://github.com/fplll/fplll) and [Sollya](http://sollya.gforge.inria.fr/).

On Linux:

```
$ sudo apt-get install libxml2-dev libgmp-dev libmpfr-dev libmpfi-dev libfplll-dev autoconf libtool automake libboost-all-dev libsollya-dev
```

Install Gappa from its [source code](http://gappa.gforge.inria.fr/).

To install the appropriate version of Metalibm extract daisy/lib/metalibm.zip to metalibm/ (i.e. in the daisy home directory), add paths to Sollya and Gappa to your PATH and run the script 'metalibm_install.sh':

```
$  source metalibm_install.sh
```

Check that your PATH contains path to Sollya, Gappa and Metalibm. Check that the system environment has `METALIBM_PATH=path/to/metalibm/`. 

### Xilinx Vivado High Level Synthesis Tool
#### MacOS
Unfortunately Xilinx Vivado HLS is NOT available for MacOS. However, the tool is only needed for performance evaluation. You can synthesize approximate programs using Daisy without compiling them with Vivado HLS. The scripts 'synthesis_\*.sh' will automatically skip the compilation and only present synthesis metrics.

#### Linux
To be able to reproduce results of performance evaluation, one needs to install the [Xilinx Vivado High Level Synthesis](https://www.xilinx.com/products/design-tools/vivado.html) tool. For that execute the command:
Install the tool with a license "Vivado HL WebPACK", it is free of charge and sufficient for the experiments.During the installation you will be asked to install several components. These are necessary:
 + Design Tools: 
    + Vivado Design Suite: Vivado
    + SDK: SDK Core Tools
 + Devices: Production Devices: SoCs: Zync 7000
 
This will require approximately 16GB of disk space.

*Note*: We have performed our experiments with Xilinx Vivado HLS **v.2019.1**.

After the installation is complete put the following commands into ~/.bash_profile (~/.bashrc):
```
$ source /path_to_Xilinx/Vivado/2019.1/.settings64-Vivado.sh
$ source /path_to_Xilinx/SDK/2019.1/.settings64-SDK_Core_Tools.sh
```
This will make a Vivado HLS `vivado_hls` executable from all directories. 

### Parse results
After performing experiments the scripts will parse Daisy's log files and Xilinx report files and collect data in a table. Parsing scripts requires **Python3** and the package **pandas** installed.
MacOS:

```
$ brew install python3
$ pip3 install pandas
```

Linux:

```
$ sudo apt-get install python3
$ pip3 install pandas
```


## Running experiments from the paper
The experiments are described in the paper in section 4.
The experiments are set up as scripts, which will run Daisy on all benchmarks
with the correct flags. Each 'synthesis_target_*.sh' script will produce results, presented in tables 1 and 2, separately for small and large target errors:

####
- synthesis_target_large.sh
- synthesis_target_small.sh
- synthesis_subset.sh

For instance, the 'synthesis_target_large.sh' script will run Daisy on a set of benchmarks with large target errors ('synthesis_target_small.sh' - on benchmarks with small target errors).
It will synthesize the approximate programs, which are then compiled using Xilinx Vivado HLS tool, that generates reports with number of machine cycles for each benchmark. Then the script parses log-file of execution of Daisy and 
corresponding reports to provide the results in a unified table form.
While running the script will create some temporary files (impl.c*, *.gappa, accel_\*) and remove them at the end of a successful run.

Running full experiments (especially for small target errors) may take a while (> 30 min). To run a subset experiments on a subset of benchmarks (axisRotationX/Y, forwardk2jX, pendulum2) use the script 'synthesis_subset.sh'. The script will produce results for the four benchmarks for both large and small error bounds. Estimated running time of 'synthesis_subset.sh' is 24.5 minutes.

The results are printed to the terminal. Synthesized approximate programs can be found in the directories output/source_large/, output/source_small/, and  output/source_\*_subset/ respectively. Reports \*.rpt containing number of machine cycles for each benchmark are generated by Xilinx Vivado HLS and can be found in the directories output/results_large/, output/results_small/ and output/results_*_subset. In the report "Latency" value is the number of machine cycles (i.e. presented results).

The scripts were successfully run in the [Ubuntu 18.1 virtual machine](https://zenodo.org/record/2759473) on a MacBook Pro with 3.1 GHz Intel Core i5 with 16GB Memory and allocated 97,66GB disk space.
Daisy will occasionally print warnings, e.g. when local roundoff error budget could not be satisfied for a polynomial. This is expected. Note that the error bound is always satisfied for the top-level program.
